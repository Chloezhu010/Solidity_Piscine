# Project P02 – Vault Lockbox

**Level:** Intermediate  
**Estimated Time:** 3–4 days  

---

## Objective
Create a time-locked vault that allows users to deposit and withdraw ETH after a specified lock period.

---

## Learning Goals
- Work with `struct` and `mapping` for user data.
- Use `block.timestamp` for time-based conditions.
- Emit and handle events.

---

## Requirements
1. **Contract**
   - Users can `deposit(uint256 lockTime)` ETH.
   - Funds can only be withdrawn after the lock period via `withdraw()`.
   - Owner can call `emergencyWithdraw()` to retrieve all ETH.

2. **Events**
   - `Deposited(address indexed user, uint256 amount, uint256 unlockTime)`
   - `Withdrawn(address indexed user, uint256 amount)`

3. **Edge Cases**
   - Prevent withdrawing before unlock.
   - Handle multiple deposits per user (design decision: aggregate or separate?).

---

## Deliverables
- `VaultLockbox.sol`
- Foundry tests for deposit, withdrawal, and emergencyWithdraw.
- `README.md` explaining:
  - How you store deposits.
  - Security considerations.

---

## Bonus Challenges
### Gas Optimization
- Use **struct packing** to reduce storage cost (combine amount + unlockTime in one slot).

### Security
- Add **reentrancy protection** to withdrawals.
- Discuss implications of using `block.timestamp` vs block numbers.

### Research
- Read OpenZeppelin’s `TimelockController` and summarize differences in 1 page.

---

## Peer Review Defense
Be prepared to explain:
- Your storage model for multiple deposits.
- How you prevent reentrancy.
- Why you chose timestamp-based locks.

---

## Resources
- [Solidity Struct Packing](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#structs-and-arrays)  
- [OpenZeppelin TimelockController](https://docs.openzeppelin.com/contracts/4.x/api/governance#TimelockController)  
- [Reentrancy Explained](https://solidity-by-example.org/hacks/re-entrancy/)
